@startuml
    skinparam Linetype ortho

    package USDs {
        class USDs implements IERC20 {
            # mint(address _account, uint256 _amount) onlyVault
            # burn(uint256 _amount) onlyVault
            ' Rebase function can internally call burnExclFromOutFlow and changeSupply
            ' Saving us multiple external calls
            # rebase(uint256 _amount) onlyVault
            # rebaseOptIn(address) onlyOwner
            # rebaseOptOut(address) onlyOwner
        }
    }

    package Vault {
        'Vault contract handles the corelogic for functioning of USDs.
        'It should only expose external and atomic calls for the user.
        'It should not have any accounting of its own.
        class VaultCore {
            - address constant USDs
            - bytes32 constant REBASER
            - bytes32 consatnt ALLOCATOR
            - bytes32 constant HARVESTOR

            + address feeVault
            + address yieldReceiver
            + address collateralManager
            + address feeCalculator

            # updateFeeVault() onlyOwner
            # updateCollateralManager() onlyOwner
            # updateYieldReceiver() onlyOwner

            ' The role of Rebase manager is to push USDs in the Vault contract for performing the rebase
            ' Initially we can carry on the same set of opperation to carry out rebase.
            # rebase(uint256 _amount) onlyRebaser external

            ' Validation for allocation to happen at the collateral manager contract.
            ' Should validates following aspects:
            ' 1. Collateral is mapped with the strategy
            ' 2. Allocation is not paused for the collateral.
            ' 3. Allocation is not exceeding the maxAllocation
            # allocate(address _collateral, address _strategy, uint256 _amount) onlyAllocator external

            + mint(address _collateral, uint256 _collateralAmt, uint256 _mintUSDsAmt, uint256 _deadline) external
            + redeem(address _collateral, uint256 _usdsAmt, uint256 _minCollAmt, uint256 _deadline) external
            + redeem(address _collateral, uint256 _usdsAmt, uint256 _minCollAmt, uint256 _deadline, address _strategyAddr) external
            + mintView(address _collateral, uint256 _collateralAmt) external view returns(uint256 _mintUSDAmt)
            + redeemView(address _collateral, uint256 _collateralAmt) external view returns(uint256 _redeemedCollAmt)
            + redeemView(address _collateral, address _strategy, uint256 _collateralAmt) external view returns(uint256 _redeemedCollAmt)

            - _mint()
            - _redeem()
            - _redeemView()
        }


        ' Handles the simple fee calculation logic
        ' Uses information from the collateral manager to
        ' We can skip this if the current logic is just to chare the base fee for the collateral.
        class FeeCalculator{
            + getFeeIn(CollateralMintData _data, TokenPriceData _priceData)
            + getFeeOut(CollateralRedeemData _data, TokenPriceData _priceData)
        }

        'All the necessary information for a collateral
        struct CollateralData {
            + uint8 id;
            + bool added;
            + bool mintAllowed;
            + bool redeemAllowed;
            + bool allocationAllowed;
            + uint256 collateralCapacityUsed;
            + uint8 basefeeIn;
            + uint8 basefeeOut;
            + uint32 downsidePeg;
            + uint32 upsidePeg;
        }

        ' All the necessary information for minting via a collateral
        struct CollateralMintData{
            uint8 baseFeeIn;
            uint32 upsidePeg;
        }

        ' All the necessary information for redeeming via a collateral
        struct CollateralRedeemData{
            uint8 baseFeeOut;
            uint32 downsidePeg;
        }

        ' All the necessary information required for allocation of a collateral to strategy.
        struct StrategyData{
            + uint8 id;
            + uint256 allocationPercentage;
        }

        class CollateralManager {
            + address[] allCollaterals
            + uint256 numCollaterals
            - Map[address => CollateralData] collateralInfo
            + Map[address => StrategyData[]] strategyInfo
            # addCollateral(address _collateral) onlyOwner
            # updateCollateralData() onlyOwner
            # removeCollateral(address _collateral) onlyOnwer
            + getMintParams() external view => CollateralMintData
            + getRedeemParams() external view => CollateralRedeemData
            + getCollateralFeeData() external => CollateralFeeData
            + validateAllocation(address _collateral, address _strategy, uint256 _amount) external => bool
        }

        VaultCore -- CollateralManager
        CollateralManager -- CollateralData
        CollateralManager -- CollateralMintData
        CollateralManager -- CollateralRedeemData
        CollateralManager -- StrategyData
        VaultCore -- FeeCalculator
    }

    package Oracle {
        ' Price feed configuration for a token.
        struct PriceFeedData {
            + address source
            + bytes calldata
        }

        ' Return data of getPrice()
        struct priceData{
            uint256 price;
            uint256 precision;
        }

        ' One single point of fetching price feeds for all of our contracts.
        class MasterPriceOracle {
            - map[address => PriceFeedData] public tokenPriceFeed;

            ' While updating the pricefeed ensure check the price feed in the function.
            # updateTokenPriceFeed(address _token, address _source, bytes memory _data) onlyOwner
            # removeTokenPriceFeed(address _token) onlyOwner
            + getPrice(address _token) => TokenPriceData
            - getPriceFeed(address _token, address _source, bytes memory _data) 
        }

        ' Can manage custom price feeds like UniV3 feed for SPA
        class CustomOracle {
            + getSPAPrice()
            + getUSDsPrice()
            + getVstPrice()
        }

        ' Can manage chainlink pricefeeds for all the tokens.
        class ChainlinkOracle {
            + getChainlinkPriceFeed(address _token)
        }

        MasterPriceOracle -- TokenPriceData
        MasterPriceOracle -- PriceFeedData
        MasterPriceOracle -- CustomOracle
        MasterPriceOracle -- ChainlinkOracle
    }

    package Strategy {
        interface IStrategy {
            + address yieldReceiver
            + address vaultCore
            # updateVaultCore() onlyOwner
            # updateYieldReciever() onlyOwner
            # deposit(address _asset, uint256 _amount) onlyVault
            # withdraw(address _recipient, address _asset, uint256 _amount) onlyVault
            # withdrawToVault(address _asset, uin256 _amount) onlyOwner
            # allocate()
            + harvestInterest(address _asset)
            + harvestRewards()
            + checkInterestEarned(address _asset)
            + checkRewardEarned()
            + supportsCollateral()
        }

        class XStrategy implements IStrategy {}
    }

    package Rebase {
        ' Earns all the yields from the strategies
        ' Performs the following roles:
        ' 1. Swap the earned yield to Stable coins | USDs
        ' 2. Transfer x% for rebase keep (100-x)% for buyback
        class Minter_and_Swapper_and_Buyback {}
        ' Initially Rebase manager can be skipped and the funds can directly go to
        ' Vault contract for doing rebase.
        class RebaseManager {}
    }

    Package Operator {
        ' Have a functionality to allow veSPA holders with 1M+ SPA
        ' Enabling the harvestor to earn a base percentage.
        class Harvestor {}

        class Allocator {}
    }


    USDs -down- VaultCore
    VaultCore -- MasterPriceOracle
    VaultCore -- IStrategy
    IStrategy -up- Minter_and_Swapper_and_Buyback
    Minter_and_Swapper_and_Buyback -right- RebaseManager
    RebaseManager -right- VaultCore